# Semaphore

<!--[>[![CircleCI](https://circleci.com/gh/kobigurk/semaphore.svg?style=svg&circle-token=57fa2a6c591cd8d09ddae610313452bdd7b0fb14)](https://circleci.com/gh/kobigurk/semaphore)<]-->

Join the [Telegram group](https://t.me/joinchat/B-PQx1U3GtAh--Z4Fwo56A) to discuss.

## Introduction

Originally devised by Barry WhiteHat, Harry Roberts, and Kobi Gurkan, Semaphore
is a system which allows any Ethereum user to signal their endorsement of an
arbitrary string, revealing only that they have been previously approved to do
so, and not their specific identity. To be precise, it lets a user:

1. Register their identity in a smart contract, and then:

2. Broadcast a signal — that is:

    - Anonymously prove that their identity is in the set of registered
      identities, and at the same time:

    - Publicly store an arbitrary string in the contract, if and only if that
      string is unique to the user and the contract’s current external
      nullifier (more on this below). This means that double-signalling the
      same message under the same external nullifier is not possible.

Semaphore consists of a smart contract and zero-knowledge proof components
which work in tandem. The smart contract handles state, permissions, and proof
verification on-chain. The zero-knowledge components work off-chain to allow
the user to generate proofs, which allow the smart contract to update its state
if these proofs are valid.

This repository contains the code for Semaphore's contracts written in
Soliidty, and zk-SNARK circuit written in
[circom](https://github.com/iden3/circom). It also contains Typescript code to
execute tests.

The code has been audited by ABDK Consulting. Their suggested security and
efficiency fixes have been applied.

A multi-party computation to produce the zk-SNARK proving and verification keys
for Semaphore will begin in the near future.

Read a high-level description of Semaphore [here](https://medium.com/coinmonks/to-mixers-and-beyond-presenting-semaphore-a-privacy-gadget-built-on-ethereum-4c8b00857c9b).

Try a simple demo here: https://weijiekoh.github.io/semaphore-ui/

## Quick start

You should have Node 11.14.0 installed. Use
[`nvm`](https://github.com/nvm-sh/nvm) to install it.

Clone this repository, install dependencies, and build the source code:

```bash
git clone git@github.com:kobigurk/semaphore.git && \
npm i && \
npm run bootstrap && \
npm run build
```

Next, either download the compiled zk-SNARK circuit, proving key, and
verification key (note that these keys are for testing purposes, and not for
production, as there is no certainty that the toxic waste was securely
discarded).

To download the circuit, proving key, and verification key, run:

```bash
./circuits/scripts/download_snarks.sh
```

To generate the above files locally instead, run:

```bash
./circuits/scripts/build_snarks.sh
```

This process should take about 45 minutes.

Build the Solidity contracts (you need `solc` v 0.5.12 installed in your `$PATH`):

```bash
cd contracts && \
npm run compileSol
```

Run tests while still in the `contracts/` directory:

```bash
# The first command tests the Merkle tree contract and the second # tests the
Semaphore contract
npm run test-semaphore && \ 
npm run test-mt
```

## How to use Semaphore in your dApp

The Semaphore contract is the base layer of Semaphore. Other contracts can
build upon this to create applications that rely on anonymous signaling.

First, you should have the proving key, verification key, and circuit file,
which are static, easily available to your users.

To have full flexibility over Semaphore's mechanisms, you should write a Client
contract and set the owner of the Semaphore contract as the address of the
Client contract. This allows the Client contract to call certain critical
Semaphore functions.

See [SemaphoreClient.sol](./contracts/sol/SemaphoreClient.sol) for an example.

### Semaphore functions

#### `insertIdentity(uint256 _identityCommitment)`

This inserts the user's identity commitment into the Semaphore contract's
Merkle tree of identities.

The client should generate it using
[`libsemaphore`](https://github.com/weijiekoh/libsemaphore)'s
`genIdentityCommitment()` function.

#### `broadcastSignal(...)`

The full function signature is:

```
broadcastSignal(
    bytes memory _signal,
    uint256[2] memory _a,
    uint256[2][2] memory _b,
    uint256[2] memory _c,
    uint256 _root,
    uint256 _nullifiersHash,
    uint256 _externalNullifier
)
```

<!--TODO: refactor libsemaphore to be friendly to the new signature of-->
<!--broadcastSignal and rewrite the following explanation-->
<!--Basically, it would be useful to have a helper function that abstracts over
the production of these values-->

- `_signal`: The signal to broadcast. Use `ethers.utils.toUtf8Bytes(SIGNAL)` to
  generate it, where `SIGNAL` is a string.

- `_a`, `_b`, and `_c`: Components of the zk-SNARK proof generated by
  `libsemaphore`'s `formatForVerifierContract()` function.

- `_root`: The root of the Merkle tree. This is part of the output of
  `libsemaphore`'s `genWitness()` function.

- `_nullifiersHash`: A uniquely derived hash of the external nullifier, user's
  identity nullifier, and the Merkle path index to their identity commitment.
  It ensures that a user cannot broadcast a signal with the same external
  nullifier more than once.

- `_externalNullifier`: A 29-byte value which serves as a context of sorts for
  the signal. Refer to the [high-level explanation of
  Semaphore](https://medium.com/coinmonks/to-mixers-and-beyond-presenting-semaphore-a-privacy-gadget-built-on-ethereum-4c8b00857c9b)
  for more details.

4. (Optional) Has functions which call the Semaphore contract's:

    - `addExternalNullifier()`

    - `deactivateExternalNullifier()`

    - `reactivateExternalNullifier()`

These functions add, deactivate, and reactivate an external nullifier respectively.
As each identity can only signal once to an external nullifier, and as a signal
can only be successfully broadcasted to an active external nullifier, these
functions enable use cases where it is necessary to have multiple external
nullifiers or to activate and/or deactivate them.

5. (Optional) There is also a function which controls broadcast permissioning:
   `setPermissioning(bool _newPermission)`. If permissioning is set to `true`,
   then only the owner (usually the Client contract) may call
   `broadcastSignal()`. Otherwise, anyone may do so.

## The zk-SNARK circuit

The [semaphore-base.circom](./circuits/circom/semaphore-base.circom) circuit
helps to prove the following:


### That the identity commitment exists in the Merkle tree

**Private inputs:**

- `identity_pk`: the user's EdDSA public key
- `identity_nullifier`: a random 32-byte value which the user should save
- `identity_trapdoor`: a random 32-byte value which the user should save
- `identity_path_elements`: the values along the Merkle path to the
  user's identity commitment
- `identity_path_index[n_levels]`: the direction (left/right) per tree level
  corresponding to the Merkle path to the user's identity commitment


**Public inputs:**

- `root`: The Merkle root of the identity tree

**Procedure:**

The circuit hashes the public key, identity nullifier, and identity trapdoor to
generate an **identity commitment**. It then verifies the Merkle proof against
the Merkle root and the identity commitment.

### That the signal was only broadcasted once

**Private inputs:**

- `identity_nullifier`: as above
- `identity_path_index`: as above

**Public inputs:**

- `external_nullifier`: the 29-byte external nullifier - see above
- `nullifiers_hash`: the hash of the identity nullifier, external nullifier,
  and Merkle path index (`identity_path_index`)

**Procedure:**

The circuit hashes the given identity nullifier, external nullifier, and Merkle
path index, and checks that it matches the given nullifiers hash. Additionally,
the smart contract ensures that it has not previously seen this nullifiers
hash. This way, double-signalling is impossible.

### That the signal was truly broadcasted by the user who generated the proof

**Private inputs:**

- `identity_pk`: as above
- `auth_sig_r`: the `r` value of the signature of the signal
- `auth_sig_s`: the `s` value of the signature of the signal

**Public inputs:**

- `signal_hash`: the hash of the signal
- `external_nullifier`: the 29-byte external nullifier - see above

**Procedure:**

The circuit hashes the signal hash and the external nullifier, and verifies
this output against the given public key and signature. This ensures the
authenticity of the signal and prevents front-running attacks.

## Cryptographic primitives

Semaphore uses MiMC for the Merkle tree, Pedersen commmitments for the identity
commitments, Blake2 for the nullifiers hash, and EdDSA for the signature.

MiMC is quite a new hash function, so it's worth discussing its security. There
are some hints to its security - we're using the recommended MiMC construction
from https://eprint.iacr.org/2016/492.pdf, and there's a prize to break MiMC at
http://mimchash.org/ which hasn't been claimed yet.

## Audit results

The [Ethereum Foundation](https://ethereum.org/) and [POA
Network](https://www.poa.network/) commissioned [ABDK
Consulting](https://www.abdk.consulting) to audit the source code of Semaphore
as well as [circomlib](https://github.com/iden3/circomlib), which contains
components which the Semaphore zk-SNARK uses.

The results of the audit can be found in the [audit/](./audit) directory. The
team's responses to their results can be found in
[audit/README.md](./audit/README.md).
